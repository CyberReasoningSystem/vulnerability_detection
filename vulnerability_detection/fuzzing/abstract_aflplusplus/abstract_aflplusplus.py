import abc
import os
import re
import shutil
import time
import typing
import uuid
from pathlib import Path
from threading import Thread

import docker

from vulnerability_detection.configuration import Configuration
from vulnerability_detection.crash_core.input_surface import InputSurface
from vulnerability_detection.fuzzing.base_fuzzer import BaseFuzzer
from vulnerability_detection.crash_core.crash import Crash
from vulnerability_detection.crash_core.input_streams import InputStream

BINARY_FILENAME = "binary"
SOURCE_FOLDER = "/tmp/fuzzer/{}/source"
SAMPLE_INPUTS_FOLDER = "/tmp/fuzzer/{}/sample_inputs"
OUTPUT_FOLDER = "/tmp/fuzzer/{}/output"
CRASHES_FOLDER = "/tmp/fuzzer/{}/output/default/crashes/"


class SessionFolderStructure:
    source_folder: str
    sample_inputs_folder: str
    output_folder: str
    crashes_folder: str

    def __init__(
        self,
        source_folder: str,
        sample_inputs_folder: str,
        output_folder: str,
        crashes_folder: str,
    ) -> None:
        self.source_folder = source_folder
        self.sample_inputs_folder = sample_inputs_folder
        self.output_folder = output_folder
        self.crashes_folder = crashes_folder


class AFLPlusPlusCrashWatcher:
    __fuzzer: typing.TypeVar("AFLPlusPlus")

    __folder: Path
    __last_known_crash: int
    __pooling_interval: int
    __thread: Thread
    __stop_needed: bool
    __folder_structure: SessionFolderStructure

    def __init__(
        self,
        fuzzer: typing.TypeVar("AFLPlusPlus"),
        folder: Path,
        pooling_interval: int,
    ) -> None:
        self.__fuzzer = fuzzer
        self.__folder = folder
        self.__pooling_interval = pooling_interval

        self.__stop_needed = False
        self.__last_known_crash = -1

        self.__thread = Thread(target=self.__watch)
        self.__thread.start()

    def __del__(self) -> None:
        self.stop()

    def __watch(self) -> None:
        while not self.__stop_needed:
            files = os.listdir(self.__folder)
            max_new_id = -1
            new_crashes = []
            for file in files:
                matches = re.match(r"^id:([0-9]{6})", file)
                if matches:
                    crash_id = int(matches.group(1))

                    if crash_id > self.__last_known_crash:
                        new_crashes.append(file)

                        if crash_id > max_new_id:
                            max_new_id = crash_id

            if max_new_id > self.__last_known_crash:
                self.__last_known_crash = max_new_id

            for crash in new_crashes:
                self.__fuzzer.crash_callback(crash)

            time.sleep(self.__pooling_interval)

    def stop(self) -> None:
        self.__stop_needed = True

        time.sleep(self.__pooling_interval)


class AFLPlusPlus(BaseFuzzer):
    __SUPPORTED_INPUT_STREAMS = [
        InputStream.FILES,
        InputStream.STANDARD_INPUT,
    ]
    __session_id: str
    __crash_watcher: AFLPlusPlusCrashWatcher
    configuration: object = Configuration.AFLPlusPlus
    __folder_structure: SessionFolderStructure

    def __init__(self, input_streams: list = None) -> None:
        if input_streams:
            streams = input_streams
        else:
            streams = self.__SUPPORTED_INPUT_STREAMS
        super().__init__(streams)

        self.__session_id = uuid.uuid4().hex

        self.__crash_watcher = None
        self.__folder_structure = None

    def __del__(self) -> None:
        self.__crash_watcher.stop()

    def _start_fuzzing(self) -> None:
        client = docker.from_env()
        image = self.__build_image_if_not_already_built(client)
        volumes = self.__init_and_get_session_volumes()
        container = self.__create_container(client, image, volumes)

        self._watch_crashes()

        self.__run_aflplusplus(container)

    def __init_and_get_session_volumes(self) -> None:
        self.__folder_structure = self.__generate_session_folder_structure()
        self.__create_folder_structure(self.__folder_structure)

        return self.__get_session_volumes(self.__folder_structure)

    def __generate_session_folder_structure(self) -> SessionFolderStructure:
        source_folder = SOURCE_FOLDER.format(self.__session_id)
        sample_inputs_folder = SAMPLE_INPUTS_FOLDER.format(self.__session_id)
        output_folder = OUTPUT_FOLDER.format(self.__session_id)
        crashes_folder = CRASHES_FOLDER.format(self.__session_id)

        return SessionFolderStructure(
            source_folder, sample_inputs_folder, output_folder, crashes_folder
        )

    def __create_folder_structure(
        self, structure: SessionFolderStructure
    ) -> None:
        os.makedirs(structure.source_folder)
        os.makedirs(structure.output_folder)
        os.makedirs(structure.crashes_folder)

        binary = os.path.join(structure.source_folder, BINARY_FILENAME)
        shutil.copyfile(self._binary, binary)
        shutil.copytree(self._sample_inputs, structure.sample_inputs_folder)

        self._create_additional_folder_structure(structure)

    @abc.abstractmethod
    def _create_additional_folder_structure(
        self, structure: SessionFolderStructure
    ) -> None:
        raise NotImplementedError()

    def __get_session_volumes(self, structure: SessionFolderStructure) -> None:
        return {
            structure.source_folder: {"bind": "/target/source", "mode": "rw"},
            structure.sample_inputs_folder: {
                "bind": "/target/sample_inputs",
                "mode": "ro",
            },
            structure.output_folder: {
                "bind": "/target/analysis",
                "mode": "rw",
            },
        }

    def __build_image_if_not_already_built(
        self, client: docker.DockerClient
    ) -> None:
        if self.configuration.IMAGE_ID:
            return

        images = client.images.build(
            path=".",
            pull=True,
            buildargs={
                "USER_ID": str(os.getuid()),
                "GROUP_ID": str(os.getgid()),
            },
        )
        image = images[0]

        return image

    def __create_container(
        self,
        client: docker.DockerClient,
        image: docker.models.images.Image,
        volumes: dict,
    ) -> None:
        used_image_id = self.__get_image_id_depending_on_config(image)

        return client.containers.run(
            used_image_id,
            command="tail -f /dev/null",
            detach=True,
            environment={
                "AFL_I_DONT_CARE_ABOUT_MISSING_CRASHES": 1,
                "AFL_USE_QASAN": 1,
            },
            tty=True,
            volumes=volumes,
        )

    def __get_image_id_depending_on_config(
        self, image: docker.models.images.Image
    ) -> str:
        if self.configuration.IMAGE_ID:
            return self.configuration.IMAGE_ID

        return image.id

    def __run_aflplusplus(
        self, container: docker.models.containers.Container
    ) -> None:
        container.exec_run("sudo chmod +x /target/source/binary")
        container.exec_run("sudo chmod +x /target/source/adapter")

        fuzzing_command = self._get_fuzzing_command()
        container.exec_run(
            fuzzing_command,
            workdir="/AFLplusplus",
        )

    @abc.abstractmethod
    def _get_fuzzing_command(self) -> None:
        raise NotImplementedError()

    def _watch_crashes(self) -> None:
        self.__crash_watcher = AFLPlusPlusCrashWatcher(
            self,
            self.__folder_structure.crashes_folder,
            self.configuration.POLLING_INTERVAL,
        )

    def crash_callback(self, crash_file: Path) -> None:
        crash = self.__create_crash_object(crash_file)
        self._add_new_crash(crash)

    def __create_crash_object(self, crash_file: str) -> None:
        full_crash_name = os.path.join(
            self.__folder_structure.crashes_folder, crash_file
        )
        with open(full_crash_name, "rb") as crash_file:
            content = crash_file.read()
            crash = Crash([InputSurface(content, self._input_stream)])

            return crash
