import abc
import os
import typing

from vulnerability_detection.exceptions import (BinaryNotFoundError,
                                                InputStreamNotSupportedError,
                                                SampleInputsNotFoundError)
from vulnerability_detection.fuzzing.crash import Crash, CrashConsumer
from vulnerability_detection.fuzzing.input_streams import InputStream


class BaseFuzzer(abc.ABC):
    _supported_input_streams: typing.List[InputStream]
    _supported_coniguration_keys: typing.List[str]
    _input_stream: InputStream
    _configuration: dict
    _binary: str
    _sample_inputs: str
    _all_crashes: typing.List[Crash]
    _crash_consumers: typing.List[CrashConsumer]
    _logs: typing.List[str]

    def __init__(self, supported_streams: typing.List[InputStream]) -> None:
        self._supported_input_streams = supported_streams

        self._input_stream = None
        self._configuration = None
        self._binary = None
        self._sample_inputs = None
        self._all_crashes = []
        self._crash_consumers = []
        self._logs = []

    def set_input_stream(self, stream: InputStream) -> None:
        if stream not in self._supported_input_streams:
            raise InputStreamNotSupportedError()

        self._input_stream = stream

    def set_target(self, binary_path: str, sample_inputs: str) -> None:
        if not os.path.isfile(binary_path):
            raise BinaryNotFoundError()

        if not os.path.isdir(sample_inputs):
            raise SampleInputsNotFoundError()

        self._binary = binary_path
        self._sample_inputs = sample_inputs

    def attach_consumer(self, consumer: CrashConsumer) -> None:
        self._crash_consumers.append(consumer)

    def start_fuzzing(self) -> None:
        self._start_fuzzing()
        self._watch_crashes()

    @abc.abstractmethod
    def _start_fuzzing(self) -> None:
        raise NotImplementedError()

    @abc.abstractmethod
    def _watch_crashes(self) -> None:
        # Must call self._add_new_crash() for each new crash that is detected
        raise NotImplementedError()

    def _add_new_crash(self, crash: Crash) -> None:
        self._all_crashes.append(crash)

        for consumer in self._crash_consumers:
            consumer.notify_new_crash(crash)

    def get_unconsumed_crashes_count(self) -> int:
        return len(self._all_crashes)

    def get_all_crashes(self) -> typing.List[Crash]:
        return self._all_crashes

    def get_last_logs(self) -> typing.List[str]:
        logs = self._logs

        self._logs = []

        return logs
