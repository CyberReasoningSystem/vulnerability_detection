import angr
import claripy
import sys
from angr.simos import path_constraint

STDIN_SIZE = 20

class AngrSetup:
    def __init__(self, exec_path):
        self._input_str = claripy.BVS('input_str', 8 * STDIN_SIZE)
        self._project = angr.Project(exec_path)
        self._state = self._project.factory.entry_state(args=[f'./{exec_path}'], stdin=self._input_str)
        self._simgr = self._project.factory.simgr(self._state)

def run_basic_mem_err(exec_path):
    print("Running a basic memory errors exploit\n")
    angr_setup = AngrSetup(exec_path = exec_path)

    angr_setup._simgr.explore()

    while len(angr_setup._simgr.active) > 0:
        angr_setup._simgr.step()

        # Check for errors in the current path
        for path in angr_setup._simgr.active:
            # Check if the program has crashed or is in an error state
            if path.errored or path.crashed:
                # Print the input value that led to the error
                input_value = path.state.se.any_str(input_str)
                print(f"Input value that caused error: {input_value}")

        # Check for paths that have reached the end of the program successfully
        angr_setup._simgr.move(from_stash='active', to_stash='found', filter_func=lambda p: p.addr == project.entry)


def run_buffer_overflow(exec_path):
    print("Running a buffer overflow exploit\n")
    angr_setup = AngrSetup(
        exec_path = exec_path
    )

    class MemSafetyPathConstraint(path_constraint.PathConstraint):
        def __init__(self):
            super().__init__()
            self.invalid_addr = None

        def copy(self):
            p = MemSafetyPathConstraint()
            p.invalid_addr = self.invalid_addr
            return p

        def merge(self, other):
            self.invalid_addr = other.invalid_addr or self.invalid_addr
            return super().merge(other)

        def satisfy(self, state):
            if self.invalid_addr is not None:
                # Check if the instruction pointer is at the invalid address
                ip = state.regs.ip
                if ip.symbolic and state.solver.satisfiable(extra_constraints=(ip == self.invalid_addr,)):
                    return state.solver.minimal_solution(ip)
            return None

    path_constraint = MemSafetyPathConstraint()

    # Create an Explorer with the custom PathConstraint
    explorer = project.factory.explorer(
        start=angr_setup._state,
        find=(angr.exploration_techniques.Except(
            angr.ExplorationError,
            only_catch=True,
            additional_callback=lambda e: path_constraint.add_constraints(e.state)
        ),),
        avoid=(),
        enable_veritesting=True,
        path_constraint=path_constraint
    )

    # Explore the program paths
    explorer.run()

    # Check if any of the paths encountered a memory violation
    for path in explorer.deadended:
        if path.errored:
            if isinstance(path.error, angr.errors.SimSegfaultError):
                print(f"Memory violation at address {hex(path.error.addr)}")
                print(f"Input value that caused error: {path.state.se.any_str(input_str)}")
            else:
                print(f"Unknown error: {path.error}")


def main(argv):
    run_basic_mem_err(argv[0])
    run_buffer_overflow(argv[0])

if __name__ == "__main__":
    main(sys.argv[1:])
