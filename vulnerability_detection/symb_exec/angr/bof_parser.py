import angr, argparse, IPython
import claripy

def check_mem_corruption(simgr):
    if len(simgr.unconstrained):
        for path in simgr.unconstrained:
            if path.satisfiable(extra_constraints=[path.regs.pc == b"CCCC"]):
                path.add_constraints(path.regs.pc == b"CCCC")
                if path.satisfiable():
                    simgr.stashes['mem_corrupt'].append(path)
                simgr.stashes['unconstrained'].remove(path)
                simgr.drop(stash='active')
    return simgr

def main():
    parser = argparse.ArgumentParser()

    parser.add_argument("Binary")

    args = parser.parse_args()

    p = angr.Project(args.Binary)

    input_size = 256  # You can adjust this value based on your needs
    input_symbol = claripy.BVS('input', input_size * 8)
    state = p.factory.entry_state(stdin=input_symbol)

    simgr = p.factory.simgr(state, save_unconstrained=True)

    simgr.stashes['mem_corrupt']  = []
    
    simgr.explore(step_func=check_mem_corruption)

    for path in simgr.stashes['mem_corrupt']:
        ok = False

        invalid_pc = path.solver.eval(path.regs.pc)
        if not p.loader.main_object.contains_addr(invalid_pc):
            print("Possible buffer overflow - Invalid Program Counter")
            ok = True

        stack_pointer = path.solver.eval(path.regs.sp)
        return_addr = path.memory.load(stack_pointer, p.arch.bytes, endness=p.arch.memory_endness)
        if not p.loader.main_object.contains_addr(path.solver.eval(return_addr)):
            print("Possible buffer overflow - Overwritten return address on the stack.")
            ok = True

        constraints = path.solver.constraints

        solver = claripy.Solver()
        solver.add(constraints)

        IPython.embed()
        inputs = solver.eval(input_symbol, 1)
        if len(inputs) > 0:
            input_str = inputs[0]

        print("Input that caused the buffer overflow:", input_str)
    
if __name__ == "__main__":
    main()

