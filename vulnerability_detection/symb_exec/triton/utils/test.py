import sys
import argparse
from triton import TritonContext, ARCH, CALLBACK, MODE
import llvm

def create_llvm_module():
    context = llvm.Context()
    module = context.module_create_with_name(b"example")
    void_type = context.void_type()
    func_type = context.function_type(void_type, [])
    main_func = module.add_function(func_type, b"main")

    return module, main_func

def run_binary(ctx, binary, module, main_func):
    with open(binary, "rb") as f:
        content = f.read()

    ctx.setArchitecture(ARCH.X86_32)
    ctx.setMode(MODE.ALIGNED_MEMORY, True)
    ctx.setCallback(CALLBACK.GET_CONCRETE_MEMORY_VALUE, lambda k: content[k.getAddress()])
    entry_point = ctx.getConcreteMemoryAreaValue(24, 4)

    ctx.setConcreteRegisterValue(ctx.registers.eip, entry_point)

    while ctx.getConcreteRegisterValue(ctx.registers.eip) != 0:
        inst = ctx.disassemble(ctx.getConcreteRegisterValue(ctx.registers.eip))
        ctx.processing(inst)
        print(inst)

        if inst.isControlFlow():
            break

def save_bitcode(module, output_file):
    buffer = llvm.MemoryBuffer.create_default_output_buffer_for_bitcode()
    module.bitcode_write(buffer)
    with open(output_file, "wb") as f:
        f.write(buffer.buffer)

def main():
    parser = argparse.ArgumentParser(description="Raise an x86_32 ELF binary to LLVM IR")
    parser.add_argument("binary", default="toy_test_suite_0.elf", help="Path to the x86_32 ELF binary")
    parser.add_argument("-o", "--output", default="output.bc", help="Output .bc file path")
    args = parser.parse_args()

    ctx = TritonContext()
    module, main_func = create_llvm_module()
    run_binary(ctx, args.binary, module, main_func)

    save_bitcode(module, args.output)
    print(f"LLVM bitcode saved to: {args.output}")

if __name__ == "__main__":
    main()

