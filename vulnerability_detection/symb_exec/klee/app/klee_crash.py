import abc
import re

from vulnerability_detection.fuzzing import CrashConsumer
from vulnerability_detection.symb_exec.klee.app.input_surface import InputSurface
from vulnerability_detection.fuzzing.input_streams import InputStream


class KleeCrash:
    input_surfaces: [InputSurface]
    executable_path: str
    source_path: str

    def __init__(self, executable_path: str = "", source_path: str = "", input_surfaces: [InputSurface] = []):
        self.input_surfaces = input_surfaces
        self.executable_path = executable_path
        self.source_path = source_path
        pass

    def add_input_surfaces(self, input_surface: InputSurface):
        self.input_surfaces.append(input_surface)

    def intake_klee_result(self, file_path: str, source_path: str = ""):
        with open(file_path, "r") as f:
            out = f.read()
            # Regular expressions to match the 'name' and 'data' lines
            name_re = re.compile(r"object +\d+: name: '(.+)'")
            data_re = re.compile(r"object +\d+: data: (b'.+?')")

            # Lists to store the names and data
            names = []
            data = []

            # Go through each line in the output
            for line in out.split('\n'):
                # Try to match the 'name' line
                name_match = name_re.match(line)
                if name_match:
                    names.append(name_match.group(1))

                # Try to match the 'data' line
                data_match = data_re.match(line)
                if data_match:
                    # eval() is used to convert the string representation of bytes to actual bytes
                    data.append(eval(data_match.group(1)))

            # Zip the names and data together into a list of tuples
            result = list(zip(names, data))

            for input in result:
                name = input[0]
                if re.match(r"arg\d+", name):
                    stream = InputStream.ARGUMENTS
                elif re.match(r"[A-Z]-data-stat", name):
                    stream = InputStream.FILES
                elif name == "stdin-stat":
                    stream = InputStream.STANDARD_INPUT
                else:
                    continue
                self.add_input_surfaces(InputSurface(
                    payload=input[1],
                    stream=stream
                ))

            self.source_path = source_path


class PrintCrashConsumer(CrashConsumer):

    def notify_new_crash(self, crash: KleeCrash) -> None:
        print(
            f":white_check_mark: New crash from {crash.source_path} source file"
        )
        for input_surface in crash.input_surfaces:
            print(f"Input stream: {input_surface.stream.name} | Payload: {input_surface.payload}")
        print("")


if __name__ == "__main__":
    klee_crash = KleeCrash()
    klee_crash.intake_klee_result("vulnerability_detection/symb_exec/klee/results/test2test000011.ptr.err.txt")
    consumer = PrintCrashConsumer()
    consumer.notify_new_crash(klee_crash)
