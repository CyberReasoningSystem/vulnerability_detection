import os
from subprocess import getstatusoutput, Popen, DEVNULL
from env import *
import time
import sys

get_timer = time.clock if sys.platform == "win32" else time.time

print(LIBC_REPLACE)

def gather_results():
    """Gathers results after all the processing is done.
    Takes all the .err files generated in each sources/<souce_folder>/<klee_last>
    and runs the ktest-tool on them to get the information, writing the results
    in the results folder.
    """
    print("Gathering results")
    sources_dir = 'sources'
    results_dir = 'results'

    # Walk throurgh each dir in the 'sources' directory
    for subdir, _, _ in os.walk(sources_dir):
        # Go into the 'klee-last' folder
        klee_out_dir = os.path.join(subdir, 'klee-last')
        for _, _, files in os.walk(klee_out_dir):
            for file in files:
                # Find all the '*.err' files generated which map to a kind of
                # error found by klee
                if file.endswith(".err"):
                    print(file)
                    filepath = os.path.join(klee_out_dir, file)
                    root, extension_err = os.path.splitext(filepath)
                    root, extension = os.path.splitext(root)
                    extension_err = extension + extension_err
                    test_filepath = root + '.ktest'

                    ret, out = getstatusoutput(f"ktest-tool {test_filepath}")

                    if ret:
                        print(f"There was an issue getting the results for \
                                file {test_filepath}")
                    else:
                        result_name = os.path.basename(subdir) + file
                        result_filepath = os.path.join(results_dir, result_name) 
                        result_filepath, ext = os.path.splitext(result_filepath)
                        result_filepath, ext = os.path.splitext(result_filepath)
                        result_filepath += extension_err + '.txt'

                        print(f"Generated err file: {result_filepath}")
                        with open(result_filepath, 'w') as f:
                            f.write(out)

    print()
    print()


def compile():
    """Compiles the source code found under 'sources' using llvm
    """
    print("Compiling stubs")
    ret, out = getstatusoutput(f"clang -I klee_build/include \
        -emit-llvm -c -g -O0 -Xclang \
        -disable-O0-optnone app/stubs.c -o stubs.bc")
    if ret:
        print(out)


    print("Compiling the files")
    sources_dir = 'sources'

    for subdir, dirs, files in os.walk(sources_dir):
        for file in files:
            if file.endswith(".c"):
                filepath = os.path.join(subdir, file)
                print(f"Compiling {filepath}")
                root, extension = os.path.splitext(filepath)
                bc_filepath = root + '.bc'
                ret, out = getstatusoutput(f"clang -I klee_build/include \
                    -emit-llvm -c -g -O0 -Xclang \
                    -disable-O0-optnone {filepath} -o {bc_filepath}")
                if ret:
                    print(out)

    print()
    print()


def generate_klee_command(compiled_file):
    """Helper for generating the 'klee' command from the environment variables.
       All the environment variables are loaded from the .env file.
    """
    command = "klee -link-llvm-lib=stubs.bc"

    if POSIX_RUNTIME:
        command = command + f" {POSIX_RUNTIME}"
        
    if LIBC_REPLACE:
        command = command + f" {LIBC_REPLACE}"

    command = command + f" {compiled_file}"

    if SYM_ARGS:
        command = command + f" -sym-args {SYM_ARGS_MIN} {SYM_ARGS_MAX} {SYM_ARGS_SIZE}"

    if SYM_STDIN:
        command = command + f" -sym-stdin {SYM_STDIN_SIZE}"

    if SYM_FILES:
        command = command + f" -sym-files {SYM_FILES_NUM} {SYM_FILES_SIZE}"

    return command

def run_klee():
    """Running klee on the compiled sources.
    """
    print("Running klee on the files")
    sources_dir = 'sources'

    for subdir, dirs, files in os.walk(sources_dir):
        for file in files:
            # Iterating through all the compiled files
            if file.endswith(".bc"):
                filepath = os.path.join(subdir, file)
                command = generate_klee_command(filepath)
                print(f"Running command: {command}")

                # Run with popen and redirect output to not clog the console
                process = Popen(
                        [command], 
                        shell=True,
                        stdout=DEVNULL,
                        stderr=DEVNULL)
                current_time = get_timer()

                # Check if the process went over the time limit or finished
                # executing
                while get_timer() < current_time + KLEE_RUN_TIMEOUT and process.poll() is None:
                    time.sleep(0.5)  # wait half a second
                # timeout expired, if it's still running, the process is stopped
                # because it went over the limit imposed by KLEE_RUN_TIMEOUT env
                # variable
                if process.poll() is None:  
                    process.terminate()
                    print("Process terminated early")
                else:
                    print("Process finished successfully")

    print()
    print()


def cleanup():
    """Cleanup before running for all the precompiled files and results
    """
    print("Running cleanup through sources")
    sources_dir = 'sources'
    results_dir = 'results'

    for subdir, dirs, files in os.walk(sources_dir):
        print(f"Cleaning {subdir}")
        ret, out = getstatusoutput(f"rm -rf {subdir}/klee-*")
        ret, out = getstatusoutput(f"rm -rf {subdir}/*.bc")

    print(f"Cleaning {results_dir}")
    ret, out = getstatusoutput(f"rm -rf {results_dir}/*")

    print()
    print()

def main():
    cleanup()
    compile()
    run_klee()
    gather_results()

if __name__ == "__main__":
    main()
