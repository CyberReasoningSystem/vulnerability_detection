import os
import re
from subprocess import getstatusoutput, Popen, DEVNULL
from env import *
import time
import sys

from vulnerability_detection.crash_core.crash import PrintCrashConsumer
from vulnerability_detection.symb_exec.klee.app.klee_crash import KleeCrash

get_timer = time.clock if sys.platform == "win32" else time.time

working_dir = 'vulnerability_detection/symb_exec/klee'

def gather_results():
    """Gathers results after all the processing is done.
    Takes all the .err files generated in each sources/<souce_folder>/<klee_last>
    and runs the ktest-tool on them to get the information, writing the results
    in the results folder.
    """
    print("Gathering results")
    sources_dir = os.path.join(working_dir, 'sources')
    results_dir = os.path.join(working_dir, 'results')

    total_errs = 0
    total_files = 0
    err_files = 0

    klee_crashes = []

    # Walk throurgh each dir in the 'sources' directory
    subdirs = [f.path for f in os.scandir(sources_dir) if f.is_dir()]
    for source_dir in subdirs:
        total_files += 1
        print(f"Crt dir: {source_dir}")
        # Go into the 'klee-last' folder
        klee_out_dir = os.path.join(source_dir, 'klee-last')
        # klee_out_dir = os.path.join(source_dir, 'klee-out-0')
        found_err = False
        for _, _, files in os.walk(klee_out_dir, followlinks=True):
            for file in files:
                # Find all the '*.err' files generated which map to a kind of
                # error found by klee
                if file.endswith(".err"):
                    total_errs += 1
                    found_err = True
                    print(file)
                    filepath = os.path.join(klee_out_dir, file)
                    root, extension_err = os.path.splitext(filepath)
                    root, extension = os.path.splitext(root)
                    extension_err = extension + extension_err
                    test_filepath = root + '.ktest'

                    ret, out = getstatusoutput(f"ktest-tool {test_filepath}")

                    if ret:
                        print(f"There was an issue getting the results for \
                                file {test_filepath}")
                    else:
                        result_name = os.path.basename(source_dir) + file
                        result_filepath = os.path.join(results_dir, result_name)
                        result_filepath, ext = os.path.splitext(result_filepath)
                        result_filepath, ext = os.path.splitext(result_filepath)
                        result_filepath += extension_err + '.txt'

                        print(f"Generated err file: {result_filepath}")
                        with open(result_filepath, 'w') as f:
                            f.write(out)

                        klee_crash = KleeCrash()
                        klee_crash.intake_klee_result(file_path=result_filepath, source_path=source_dir)
                        klee_crashes.append(klee_crash)


        if found_err:
            err_files += 1

    non_err_files = total_files - err_files

    print()
    print()

    print(f"Total binaries checked: {total_files}")
    print(f"With vulnerabilities: {err_files} | Without vulnerabilities: {non_err_files}")
    print(f"With vulnerabilities %: {(err_files) / total_files} | Without vulnerabilities %: {(non_err_files) / total_files}")
    print(f"Total vulnerabilities found: {total_errs}")

    return klee_crashes


def get_files_in_dir(directory):
    return set(os.path.join(directory, f) for f in os.listdir(directory))


def compile():
    """Compiles the source code found under 'sources' using llvm
    """
    print("Compiling stubs")
    app_dir = os.path.join(working_dir, "app")
    stubs_path = os.path.join(app_dir, "stubs.c")
    ret, out = getstatusoutput(f"clang -I klee_build/include \
        -emit-llvm -c -O0 -Xclang \
        -disable-O0-optnone {stubs_path} -o stubs.bc")
    if ret:
        print(out)


    print("Compiling the files")
    sources_dir = os.path.join(working_dir, 'sources')
    for item in os.listdir(sources_dir):
        current_path = os.path.join(sources_dir, item)
        if os.path.isdir(current_path):
            file_paths = get_files_in_dir(current_path)
            file_names = {os.path.basename(path) for path in file_paths}

            makefile_path = next(
                (path for path in file_paths if 'makefile' in os.path.basename(path).lower()), 
                None
            )

            if makefile_path is None:
                # If there is no makefile, get a list of files that end with .c.
                c_files = [path for path in file_paths if path.endswith('.c')]
                for file in c_files:
                    print(f"Compiling {file}")
                    root, extension = os.path.splitext(file)
                    bc_filepath = root + '.bc'
                    ret, out = getstatusoutput(f"clang -I /home/klee/klee_build/include\
                        -emit-llvm -c -O0 -Xclang \
                        -disable-O0-optnone {file} -o {bc_filepath}")
                    if ret:
                        print(out)
       
            else:
                print(f"Compiling {current_path}")
                root, extension = os.path.splitext(current_path)
                bc_filepath = os.path.join(root, 'makefile.bc')
                files_before = get_files_in_dir(current_path)
                ret, out = getstatusoutput(f"cd {current_path} && CC=wllvm CFLAGS='-I /home/klee/klee_build/include -emit-llvm -c -O0 -Xclang -disable-O0-optnone' make")
                if ret:
                    print(out)
                else:
                    files_after = get_files_in_dir(current_path)
                    new_files = files_after - files_before
                    for new_file in new_files:
                        os.rename(new_file, bc_filepath)



    print()
    print()
"""
                    """




def generate_klee_command(compiled_file):
    """Helper for generating the 'klee' command from the environment variables.
       All the environment variables are loaded from the .env file.
    """
    command = "klee -link-llvm-lib=stubs.bc"

    if POSIX_RUNTIME is not "false":
        command = command + f" {POSIX_RUNTIME}"
        
    if LIBC_REPLACE is not "false":
        command = command + f" {LIBC_REPLACE}"

    command = command + f" {compiled_file}"

    if SYM_ARGS != "false":
        command = command + f" -sym-args {SYM_ARGS_MIN} {SYM_ARGS_MAX} {SYM_ARGS_SIZE}"

    if SYM_STDIN != "false":
        command = command + f" -sym-stdin {SYM_STDIN_SIZE}"

    if SYM_FILES !=  "false":
        print(f"sym files: {SYM_FILES}")
        command = command + f" -sym-files {SYM_FILES_NUM} {SYM_FILES_SIZE}"

    return command

def run_klee():
    """Running klee on the compiled sources.
    """
    print("Running klee on the files")
    sources_dir = os.path.join(working_dir, 'sources')

    for subdir, dirs, files in os.walk(sources_dir):
        for file in files:
            # Iterating through all the compiled files
            if file.endswith(".bc"):
                filepath = os.path.join(subdir, file)
                command = generate_klee_command(filepath)
                print(f"Running command: {command}")

                # Run with popen and redirect output to not clog the console
                process = Popen(
                        [command], 
                        shell=True,
                        stdout=DEVNULL,
                        stderr=DEVNULL)
                current_time = get_timer()

                # Check if the process went over the time limit or finished
                # executing
                while get_timer() < current_time + KLEE_RUN_TIMEOUT and process.poll() is None:
                    time.sleep(0.5)  # wait half a second
                # timeout expired, if it's still running, the process is stopped
                # because it went over the limit imposed by KLEE_RUN_TIMEOUT env
                # variable
                if process.poll() is None:  
                    process.terminate()
                    print("Process terminated early")
                else:
                    print("Process finished successfully")

    print()
    print()


def cleanup():
    """Cleanup before running for all the precompiled files and results
    """
    print("Running cleanup through sources")
    sources_dir = os.path.join(working_dir, 'sources')
    results_dir = os.path.join(working_dir, 'results')

    for subdir, dirs, files in os.walk(sources_dir):
        print(f"Cleaning {subdir}")
        ret, out = getstatusoutput(f"rm -rf {subdir}/klee-*")
        ret, out = getstatusoutput(f"rm -rf {subdir}/*.bc")

    print(f"Cleaning {results_dir}")
    ret, out = getstatusoutput(f"rm -rf {results_dir}/*")

    print()
    print()

def main():
    cleanup()
    compile()
    run_klee()
    crashes = gather_results()
    consumer = PrintCrashConsumer()
    for crash in crashes:
        consumer.notify_new_crash(crash)

if __name__ == "__main__":
    main()
